# 1. 브루트 포스

: 모든 경우의 수를 다 해보는 것(단, 시간제한을 넘지 않아야 함)




## - 브루트 포스 3가지 단계

1. 경우의 수
: 직접 계산

2. 그냥 다 해보기
: 다 해보기, for문, 순열, 재귀 호출, 비트마스크 등 사용

3. 각각의 방법을 이용해 답 구하기
: 문제에 나온대로 답 계산해보기





## - 브루트 포스 시간 복잡도

> O(경우의 수 * 방법 1개가 걸리는 시간 복잡도)




## - 브루트 포스 풀기
: 순열과 비트마스크 모두 `재귀`로 풀 수 있음




## - 브루트 포스 풀기: 재귀

- 순서
- 선택


1. 불가능한 경우
2. 정답을 찾은 경우
3. 다음 경우 호출



## - 백트래킹
: `재귀 함수` 사용 시 `함수 호출이 의미 없는 경우를 제외`하고 진행




## - 브루트 포스 풀기: 순열
: 모든 순서를 다 시도함

>Do While문으로 모든 수열 구함



## - 브루트 포스 풀기: 비트마스크

: 정수로 집합을 나타낼 수 있음

1. 추가
2. 검사
3. 제거
4. 토글

---

# 2. 그래프
- 정점(Node, Vertex)
- 간선(Edge)

## - 경로
: 정점A에서 B로가는 경로

## - 사이클
: 정점 A에서 다시 A로 돌아오는 경로

## - 단순경로와 단순 사이클
: 같은 정점을 `두번 이상 방문 하지 않는` 경로와 사이클

## - 가중치
: 간선에 있는 `거리, 시간, 비용`

## - 차수
: 정점과 연결되어 있는 `간선의 개수`
- In-degree
- Out-degree


## - 그래프 저장 방법
: 효율적으로 찾는 구조

1. 인접 행렬: O(V^)
: 간선이 있는지 찾는 경우

2. 인접 리스트: O(E)
: 한 정점과 연결된 모든 간선을 찾는 경우


## - 그래프의 탐색
: 임의의 정점에서 시작하여 연결되어 있는 `모든 정점을 1번씩 방문`하는 것

- DFS: `Stack`
- BFS: `Queue`

## - DFS(깊이 우선 탐색)
- 재귀 호출을 이용해서 구현
- 인접리스트를 이용해서 구현:O(E)

## - BFS(너비 우선 탐색)
- 인접리스트를 이용해서 구현
- 최단거리를 구하기 좋음


## - 연결요소
: 나누어진 각각의 그래프

## - BFS 조건
1. 최소 비용 문제
2. 간선의 가중치가 1
3. 정점과 간선의 개수가 적음

## - 트리
: 사이클이 없는 연결 그래프
- 깊이: 루트에서부터의 거리
- 높이: 깊이 중 가장 큰 값

## - 이진트리
: 자식을 최대 2개만 가지고 있는 트리
- 포화 이진 트리: 모든 리프 노드의 깊이가 같음
- 완전 이진 트리: 오른쪽에서부터 몇개가 사라진 형태

## - 트리의 순회

- 프리오더: `노드` -> 왼쪽 -> 오른쪽
- 인오더: 왼쪽 -> `노드` -> 오른쪽
- 포스트오더: 왼쪽 -> 오른쪽 -> `노드`

> `포스트오더`를 제일 많이 사용
