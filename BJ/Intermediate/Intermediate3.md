# 1. DAG(Directed Acyclic Graph)
: 사이클이 없는 방향그래프

: `선행관계`

## - 위상정렬(BFS, DFS)
: 그래프의 간선 `u가 v보다 먼저`라는 의미일 때 `정점의 순서`를 찾는 알고리즘

: `in-degree가 0`일 때 `시작 정점`

- BFS
> 시간복잡도 = O(e)
: `in-degree가 0일 때 큐에` 정점 추가

: 우선순위큐(`Min-Heap`)


- DFS
: 그래프의 간선을 `모두 뒤집어 놓고` DFS 수행

: `스택에서 빠져나올 때` 정점 기록


# 2. MST(Minimum Spanning Tree, 최소 스패닝 트리)
: `그래프에서 가중치의 합이 최소인 간선`을 선택해서 만든 트리

: `사이클을 만들지 않음`

## - 프림
> 시간복잡도 = O(VE) / O(V^3) / O(logE): 우선 순위 큐

: 아무 정점을 선택한 후 `선택하지 않은 정점을 연결하는 간선 중 최소값`을 고름

: 선택한 간선을 MST에 추가, 선택하지 않은 정점로 돌아감


## - 크루스칼
: `Union-Find`

: 정점을 추가하는 프림과 반대로 `간선을 추가`하는 알고리즘


# 3. 최단 경로
: `시작점이 1개`일때, 다른 모든 곳으로 가는 최단 경로 구하기


## - 벨만포드
> 시간복잡도 = O(VE) / O(V^3)

: 가중치가 `음수`일 때도 사용가능

: 모든 간수에 대해 N-1번 검사


## - 다익스트라
> 시간복잡도 = O(V^) / O(ElogE)

: 스택 or 재귀

: `검사하지 않은 정점 중에서 dist의 값이 가장 작은 정점v를 선택`하여 시간을 줄일 수 있음(우선 순위큐 or 세그먼트 트리)


## - 플로이드
: `모든 정점`의 쌍의 최단경로

: 간단하게 구현가능(3차원배열을 2차원으로 구현)

## - SPFA
> 시간복잡도 = O(E)

: 벨만포드를 빠르게 바꾼 알고리즘

: `큐`를 사용하여 바뀐 정점 관리

: MCMF를 사용할 때 사용하는 알고리즘

