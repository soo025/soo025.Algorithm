# 1. 그리디 알고리즘
: 결정할 때 가장 좋다고 생각하는 것을 선택하며 답을 찾아가는 알고리즘 (증명)

: 최종적으로 답이 최적이 아닐 수도 있음 (반례)


---


# 2. 분할정복
: 문제를 2개 이상의 `작은 부분 문제로 나눈` 다음 푸는 알고리즘

: DP와 다르게 작은 부분 문제의 `중복 불가능`

ex) 퀵소트, 머지소트, 큰 수 곱셉, FFT

## - 이분탐색(Binary Search)
: `정렬되어 있는 리스트`에서 어떤 값을 빠르게 찾는 알고리즘

- 시간 복잡도: O(logN)
- left(최솟값) <= right(최댓값)
- 정답을 하나 결정했을 때, 문제의 `조건에 부합`하는지 검사

1. 정답을 구하는 문제
2. 가능한지(`Yes/No`) 살펴보는 문제

---

ex) 상한(Upper Bound)과 하한(Lower Bound)
- 상한: 큰 수 중 첫번째 수
- 하한: 크거나 같은 수 중 첫번째 수

## - 머지 소트(Merge Sort)
: N개를 `N/2로 나누어서` 정렬하고 합치는 알고리즘

- 시간 복잡도: O(NlogN)

## - 퀵 소트(Quick Sort)
: 피벗(pivot)을 하나 고르고 그것보다 `작은 것을 앞`으로, `큰 것을 뒤`로 보내는 알고리즘

: 평균적인 상황에서 최고의 성능

- 시간복잡도: O(NlogN) / O(N^)


---


# 3. 정렬(Sorting)
: 리스트에 담긴 자료를 `어떠한 순서로 나열`하는 것

: `라이브러리 사용`이 좋음

ex) 선택, 버블, 삽입, 퀵, 힙, 병합

## - Stable Sorting
: 같은 것이 있는 경우 `항상 입력순서를 유지`하는 정렬

ex) Merge Sort, Bubble Sort
