# 1. 유니온 파인드(Union Fine)
:`합집합`을 나타낼 때 사용

: `상호 배타적 집합`(Disjoint-set)

: 구현은 `트리`

: parent[i] = i의 parent가 저장됨

: 2가지 연산으로 이루어짐
1. Find: X가 어떤 집합에 포함되어 있는지 `찾는 연산`
> 시간복잡도 = O(N)

2. Union: X와 Y가 포함되어 있는 집합을 `합치는 연산`


---

# 2. 힙
: `최소값`과 `최대값` 찾기

: `완전 이진트리`(Complete Binary Tree)

1. 최대 힙
: 부모 노드는 자식 노드에 들어있는 값보다 큼
: 높이는 `logN`

2. 최소 힙
: 부모 노드는 자식 노드에 들어있는 값보다 작음


---


# 3. 이진 검색 트리(Binary Search Tree)
> 시간복잡도 = O(h) (균형이 맞춰져 있는 BBST일때)

ex) AVL-Tree, Red-black Tree, Splay Tree, Treap

: 현재 노드의 `왼쪽 서브트리`에는 항상 노드의 값보다 `작은 값`이, `오른쪽 서브트리`에는 항상 노드의 값보다 `큰 값`이 들어있음

: 트리의 노드에는 `자료`를 저장할 변수(data), `왼쪽 자식`을 가르키는 변수(left), `오른쪽 자식`을 가르키는 변수(right)

: 같은 데이터도 `순서에 따라 트리의 형태가 달라짐`

## - 이진 검색 트리 삽입
: 가장 `첫 노드`를 추가하는 경우에는 `root`를 새로운 노드로 설정

: 노드에 포함된 값과 `대소비교`를 하면서 왼쪽 또는 오른쪽으로 이동


## - 이진 검색 트리 삭제
: 자식이 `0`개인 경우 그냥 `지움`

: 자식이 `1`개인 경우 `노드를 지우고 자식을 이어 붙임`

: 자식이 `2`개인 경우 지우려는 노드의 값을 `in-oder순회의 바로 다음 노드으로 바꾼 후 in-oder순회의 다음 노드를 지움`


---


# 1. 문자열 검색 알고리즘
> 시간복잡도 = O(|S| * |P|)

: 문자열 S에서 `패턴 P`를 찾는 알고리즘

: S에서 가장 먼저 나타나는 P를 찾아야함

: 모든 경우를 다 해보는 알고리즘이기 때문에 느림

## - 라빈 카프 알고리즘(Rabin-Karp Algorithm)
> 시간복잡도 = O(N+M) / O(NM)

: `해시 함수`를 이용해서 문자열을 비교

: `라빈핑거프린트(Rabin Fingerprint)` 해시 함수 사용 (진법과 소수를 잘 정해야함)

## - KMP 알고리즘
: 문자열 S가 있을때 `실패함수(fail)`을 이용해서 `패턴 P`를 찾는 알고리즘

: fail[i]에는 prefix(접두사) == suffix(접미사)가 될 수 있는 `부분 문자열 중에서 가장 긴` 것의 길이

ex) 부분 문자열이 `ABCABDAB`이면 prefix는 앞의 `AB`, suffix는 뒤의 `AB`, fail[i] = `2`



## - Trie
: 문자열 N개가 있을때, 노드(어떤 문자열의 `접두사`)로 `문자열 S`를 찾는 자료구조

ex) t -> r -> i -> e



## - Aho-corasick
> 시간복잡도 = O(|S| + |P| * M)

: 문자열 N개가 있을때, `패턴 P`를 찾는 알고리즘 (Trie + KMP)


---

# 1. 거듭제곱

## - 분할(재귀)
> 시간복잡도 = O(logN)

:a^b의 b가 `짝수`일때, a^b/2 * a^b/2

:a^b의 b가 `홀수`일때, a * a^b-1

## - 이진수
> 시간복잡도 = O(logN)

:a를 계속 거듭제곱의 형태 만들고, b를 계속 2로 나누어 줌

ex) 3^37

    a = 3 -> 3^ -> 3^4 ... -> 3^16
    
    b = 27(11011) -> 13(1101) -> ... -> 1

# 2. 행렬
> 시간복잡도 = O(n^3)


# 3. 피보나치 수

## - 피사노 주기
: k로 나눈 `나머지는 주기`를 갖음

ex) 3으로 나누었을때 주기는 8


## 행렬의 거듭제곱
> 시간복잡도 = O(logN)


# 4. 이항계수
> 시간복잡도 = O(N)

: n개중에 k개를 `순서없이` 고르는 방법

: nCk는 팩토리얼 때문에 값이 커짐


## - 파스칼의 삼각형
> 시간복잡도 = O(n^)

: n번째 줄에는 `n개의 수`만 적음

: 각줄의 첫번째와 마지막 수는 `1`

: 나머지 수는 윗 줄의 왼쪽 수와 오른쪽 수의 `합`

# 5. 포함-배제의 원리
: 집합의 교집합 크기를 구할때 사용하는 방법

: |A U B|  = |A| + |B| + |A∩B|

## - 소수의 배수
: M개 이하의 자연수 중에서 N개의 소수 중 적어도 하나로 나누어 떨어지는 수의 개수

: 비트마스크 사용


