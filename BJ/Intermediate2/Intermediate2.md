# 1. 유니온 파인드(Union Fine)
:`합집합`을 나타낼 때 사용

: `상호 배타적 집합`(Disjoint-set)

: 구현은 `트리`

: parent[i] = i의 parent가 저장됨

: 2가지 연산으로 이루어짐
1. Find: X가 어떤 집합에 포함되어 있는지 `찾는 연산`
> 시간복잡도 = O(N)

2. Union: X와 Y가 포함되어 있는 집합을 `합치는 연산`


---

# 2. 힙
: `최소값`과 `최대값` 찾기

: `완전 이진트리`(Complete Binary Tree)

1. 최대 힙
: 부모 노드는 자식 노드에 들어있는 값보다 큼
: 높이는 `logN`

2. 최소 힙
: 부모 노드는 자식 노드에 들어있는 값보다 작음


---


# 3. 이진 검색 트리(Binary Search Tree)
> 시간복잡도 = O(h) (균형이 맞춰져 있는 BBST일때)

ex) AVL-Tree, Red-black Tree, Splay Tree, Treap

: 현재 노드의 `왼쪽 서브트리`에는 항상 노드의 값보다 `작은 값`이, `오른쪽 서브트리`에는 항상 노드의 값보다 `큰 값`이 들어있음

: 트리의 노드에는 `자료`를 저장할 변수(data), `왼쪽 자식`을 가르키는 변수(left), `오른쪽 자식`을 가르키는 변수(right)

: 같은 데이터도 `순서에 따라 트리의 형태가 달라짐`

## - 이진 검색 트리 삽입
: 가장 `첫 노드`를 추가하는 경우에는 `root`를 새로운 노드로 설정

: 노드에 포함된 값과 `대소비교`를 하면서 왼쪽 또는 오른쪽으로 이동


## - 이진 검색 트리 삭제
: 자식이 `0`개인 경우 그냥 `지움`

: 자식이 `1`개인 경우 `노드를 지우고 자식을 이어 붙임`

: 자식이 `2`개인 경우 지우려는 노드의 값을 `in-oder순회의 바로 다음 노드으로 바꾼 후 in-oder순회의 다음 노드를 지움`


---


# 1. 문자열 검색 알고리즘
> 시간복잡도 = O(|S| * |P|)

: 문자열 S에서 `패턴 P`를 찾는 알고리즘

: S에서 가장 먼저 나타나는 P를 찾아야함

: 모든 경우를 다 해보는 알고리즘이기 때문에 느림

## - 라빈 카프 알고리즘(Rabin-Karp Algorithm)
> 시간복잡도 = O(N+M) / O(NM)

: `해시 함수`를 이용해서 문자열을 비교

: `라빈핑거프린트(Rabin Fingerprint)` 해시 함수 사용 (진법과 소수를 잘 정해야함)

## - KMP 알고리즘
: 문자열 S가 있을때 `실패함수(fail)`을 이용해서 패턴 P를 찾는 알고리즘

: fail[i]에는 prefix(접두사) == suffix(접미사)가 될 수 있는 `부분 문자열 중에서 가장 긴` 것의 길이

ex) 부분 문자열이 `ABCABDAB`이면 prefix는 앞의 `AB`, suffix는 뒤의 'AB`, fail[i] = `2`



## - Trie
: 문자열 N개가 있을때, 노드(어떤 문자열의 `접두사`)로 문자열 S를 찾는 자료구조

ex) t -> r -> i -> e



## - Aho-corasick
> 시간복잡도 = O(|S| + |P| * M)

: 문자열 N개가 있을때, 패턴 P를 찾는 알고리즘 (Trie + KMP)
